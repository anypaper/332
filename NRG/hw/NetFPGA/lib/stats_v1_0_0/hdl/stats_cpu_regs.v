//
// Copyright (c) 2015 University of Cambridge
// All rights reserved.
//
//
//  File:
//        stats_cpu_regs.v
//
//  Module:
//        stats_cpu_regs
//
//  Description:
//        This file is automatically generated with the registers towards the CPU/Software
//
// This software was developed by Stanford University and the University of Cambridge Computer Laboratory
// under National Science Foundation under Grant No. CNS-0855268,
// the University of Cambridge Computer Laboratory under EPSRC INTERNET Project EP/H040536/1 and
// by the University of Cambridge Computer Laboratory under DARPA/AFRL contract FA8750-11-C-0249 ("MRC2"),
// as part of the DARPA MRC research programme.
//
// @NETFPGA_LICENSE_HEADER_START@
//
// Licensed to NetFPGA C.I.C. (NetFPGA) under one or more contributor
// license agreements.  See the NOTICE file distributed with this work for
// additional information regarding copyright ownership.  NetFPGA licenses this
// file to you under the NetFPGA Hardware-Software License, Version 1.0 (the
// "License"); you may not use this file except in compliance with the
// License.  You may obtain a copy of the License at:
//
//   http://www.netfpga-cic.org
//
// Unless required by applicable law or agreed to in writing, Work distributed
// under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations under the License.
//
// @NETFPGA_LICENSE_HEADER_END@
//

`include "stats_cpu_regs_defines.v"
module stats_cpu_regs #
(
parameter C_BASE_ADDRESS        = 32'h00000000,
parameter C_S_AXI_DATA_WIDTH    = 32,
parameter C_S_AXI_ADDR_WIDTH    = 32
)
(
    // General ports
    input       clk,
    input       resetn,
    // Global Registers
    input       cpu_resetn_soft,
    output reg  resetn_soft,
    output reg  resetn_sync,

   // Register ports
    input      [`REG_ID_BITS]    id_reg,
    input      [`REG_VERSION_BITS]    version_reg,
    output reg [`REG_RESET_BITS]    reset_reg,
    input      [`REG_FLIP_BITS]    ip2cpu_flip_reg,
    output reg [`REG_FLIP_BITS]    cpu2ip_flip_reg,
    input      [`REG_DEBUG_BITS]    ip2cpu_debug_reg,
    output reg [`REG_DEBUG_BITS]    cpu2ip_debug_reg,
    input      [`REG_PKTIN_BITS]    pktin_reg,
    output reg                          pktin_reg_clear,
    input      [`REG_PKTOUT_BITS]    pktout_reg,
    output reg                          pktout_reg_clear,
    input      [`REG_TESTTRIGGER_BITS]    ip2cpu_testtrigger_reg,
    output reg [`REG_TESTTRIGGER_BITS]    cpu2ip_testtrigger_reg,
    input      [`REG_BWGRANULARITY_BITS]    ip2cpu_bwgranularity_reg,
    output reg [`REG_BWGRANULARITY_BITS]    cpu2ip_bwgranularity_reg,
    input      [`REG_BWDIVISOR_BITS]    ip2cpu_bwdivisor_reg,
    output reg [`REG_BWDIVISOR_BITS]    cpu2ip_bwdivisor_reg,
    input      [`REG_BURSTGAP_BITS]    ip2cpu_burstgap_reg,
    output reg [`REG_BURSTGAP_BITS]    cpu2ip_burstgap_reg,
    input      [`REG_TESTEND_BITS]    ip2cpu_testend_reg,
    output reg [`REG_TESTEND_BITS]    cpu2ip_testend_reg,
    input      [`REG_FIRSTTIME_BITS]    ip2cpu_firsttime_reg,
    output reg [`REG_FIRSTTIME_BITS]    cpu2ip_firsttime_reg,
    input      [`REG_LASTTIME_BITS]    ip2cpu_lasttime_reg,
    output reg [`REG_LASTTIME_BITS]    cpu2ip_lasttime_reg,
    input      [`REG_LASTBW_BITS]    ip2cpu_lastbw_reg,
    output reg [`REG_LASTBW_BITS]    cpu2ip_lastbw_reg,
    output reg [`REG_INPUTSEL_BITS]    inputsel_reg,
    input      [`REG_ARPCOUNT_BITS]    ip2cpu_arpcount_reg,
    output reg [`REG_ARPCOUNT_BITS]    cpu2ip_arpcount_reg,
    input      [`REG_IP4COUNT_BITS]    ip2cpu_ip4count_reg,
    output reg [`REG_IP4COUNT_BITS]    cpu2ip_ip4count_reg,
    input      [`REG_IP6COUNT_BITS]    ip2cpu_ip6count_reg,
    output reg [`REG_IP6COUNT_BITS]    cpu2ip_ip6count_reg,
    input      [`REG_TCPCOUNT_BITS]    ip2cpu_tcpcount_reg,
    output reg [`REG_TCPCOUNT_BITS]    cpu2ip_tcpcount_reg,
    input      [`REG_UDPCOUNT_BITS]    ip2cpu_udpcount_reg,
    output reg [`REG_UDPCOUNT_BITS]    cpu2ip_udpcount_reg,
    input      [`REG_SYNCOUNT_BITS]    ip2cpu_syncount_reg,
    output reg [`REG_SYNCOUNT_BITS]    cpu2ip_syncount_reg,
    input      [`REG_FINCOUNT_BITS]    ip2cpu_fincount_reg,
    output reg [`REG_FINCOUNT_BITS]    cpu2ip_fincount_reg,
    input      [`REG_FLOWIDCOUNT_BITS]    ip2cpu_flowidcount_reg,
    output reg [`REG_FLOWIDCOUNT_BITS]    cpu2ip_flowidcount_reg,
    output reg [`REG_PATTERNMATCH1_BITS]    patternmatch1_reg,
    output reg [`REG_PATTERNMATCH2_BITS]    patternmatch2_reg,
    output reg [`REG_PATTERNMATCH3_BITS]    patternmatch3_reg,
    output reg [`REG_PATTERNMATCH4_BITS]    patternmatch4_reg,
    output reg [`REG_PATTERNMATCH5_BITS]    patternmatch5_reg,
    output reg [`REG_PATTERNMATCH6_BITS]    patternmatch6_reg,
    output reg [`REG_PATTERNMATCH7_BITS]    patternmatch7_reg,
    output reg [`REG_PATTERNMATCH8_BITS]    patternmatch8_reg,
    output reg [`REG_PATTERNMATCH9_BITS]    patternmatch9_reg,
    output reg [`REG_PATTERNMATCH10_BITS]    patternmatch10_reg,
    output reg [`REG_PATTERNMATCH11_BITS]    patternmatch11_reg,
    output reg [`REG_PATTERNMATCH12_BITS]    patternmatch12_reg,
    output reg [`REG_PATTERNMATCH13_BITS]    patternmatch13_reg,
    output reg [`REG_PATTERNMATCH14_BITS]    patternmatch14_reg,
    output reg [`REG_PATTERNMATCH15_BITS]    patternmatch15_reg,
    output reg [`REG_PATTERNMATCH16_BITS]    patternmatch16_reg,
    output reg [`REG_PATTERNMASK1_BITS]    patternmask1_reg,
    output reg [`REG_PATTERNMASK2_BITS]    patternmask2_reg,
    output reg [`REG_PATTERNMASK3_BITS]    patternmask3_reg,
    output reg [`REG_PATTERNMASK4_BITS]    patternmask4_reg,
    output reg [`REG_PATTERNMASK5_BITS]    patternmask5_reg,
    output reg [`REG_PATTERNMASK6_BITS]    patternmask6_reg,
    output reg [`REG_PATTERNMASK7_BITS]    patternmask7_reg,
    output reg [`REG_PATTERNMASK8_BITS]    patternmask8_reg,
    output reg [`REG_PATTERNMASK9_BITS]    patternmask9_reg,
    output reg [`REG_PATTERNMASK10_BITS]    patternmask10_reg,
    output reg [`REG_PATTERNMASK11_BITS]    patternmask11_reg,
    output reg [`REG_PATTERNMASK12_BITS]    patternmask12_reg,
    output reg [`REG_PATTERNMASK13_BITS]    patternmask13_reg,
    output reg [`REG_PATTERNMASK14_BITS]    patternmask14_reg,
    output reg [`REG_PATTERNMASK15_BITS]    patternmask15_reg,
    output reg [`REG_PATTERNMASK16_BITS]    patternmask16_reg,
    input      [`REG_MATCHCOUNT_BITS]    ip2cpu_matchcount_reg,
    output reg [`REG_MATCHCOUNT_BITS]    cpu2ip_matchcount_reg,
    output  reg [`MEM_PKTSIZEMEM_ADDR_BITS]    pktsizemem_addr,
    output  reg [`MEM_PKTSIZEMEM_DATA_BITS]    pktsizemem_data,
    output  reg                         pktsizemem_rd_wrn,
    output  reg                         pktsizemem_cmd_valid,
    input       [`MEM_PKTSIZEMEM_DATA_BITS]    pktsizemem_reply,
    input                               pktsizemem_reply_valid,
    output  reg [`MEM_IPGMEM_ADDR_BITS]    ipgmem_addr,
    output  reg [`MEM_IPGMEM_DATA_BITS]    ipgmem_data,
    output  reg                         ipgmem_rd_wrn,
    output  reg                         ipgmem_cmd_valid,
    input       [`MEM_IPGMEM_DATA_BITS]    ipgmem_reply,
    input                               ipgmem_reply_valid,
    output  reg [`MEM_BURSTMEM_ADDR_BITS]    burstmem_addr,
    output  reg [`MEM_BURSTMEM_DATA_BITS]    burstmem_data,
    output  reg                         burstmem_rd_wrn,
    output  reg                         burstmem_cmd_valid,
    input       [`MEM_BURSTMEM_DATA_BITS]    burstmem_reply,
    input                               burstmem_reply_valid,
    output  reg [`MEM_BWMEM_ADDR_BITS]    bwmem_addr,
    output  reg [`MEM_BWMEM_DATA_BITS]    bwmem_data,
    output  reg                         bwmem_rd_wrn,
    output  reg                         bwmem_cmd_valid,
    input       [`MEM_BWMEM_DATA_BITS]    bwmem_reply,
    input                               bwmem_reply_valid,
    output  reg [`MEM_BWTSMEM_ADDR_BITS]    bwtsmem_addr,
    output  reg [`MEM_BWTSMEM_DATA_BITS]    bwtsmem_data,
    output  reg                         bwtsmem_rd_wrn,
    output  reg                         bwtsmem_cmd_valid,
    input       [`MEM_BWTSMEM_DATA_BITS]    bwtsmem_reply,
    input                               bwtsmem_reply_valid,
    output  reg [`MEM_PPSMEM_ADDR_BITS]    ppsmem_addr,
    output  reg [`MEM_PPSMEM_DATA_BITS]    ppsmem_data,
    output  reg                         ppsmem_rd_wrn,
    output  reg                         ppsmem_cmd_valid,
    input       [`MEM_PPSMEM_DATA_BITS]    ppsmem_reply,
    input                               ppsmem_reply_valid,
    output  reg [`MEM_FLOWIDMEM_ADDR_BITS]    flowidmem_addr,
    output  reg [`MEM_FLOWIDMEM_DATA_BITS]    flowidmem_data,
    output  reg                         flowidmem_rd_wrn,
    output  reg                         flowidmem_cmd_valid,
    input       [`MEM_FLOWIDMEM_DATA_BITS]    flowidmem_reply,
    input                               flowidmem_reply_valid,
    output  reg [`MEM_WINDOWSIZEMEM_ADDR_BITS]    windowsizemem_addr,
    output  reg [`MEM_WINDOWSIZEMEM_DATA_BITS]    windowsizemem_data,
    output  reg                         windowsizemem_rd_wrn,
    output  reg                         windowsizemem_cmd_valid,
    input       [`MEM_WINDOWSIZEMEM_DATA_BITS]    windowsizemem_reply,
    input                               windowsizemem_reply_valid,

    // AXI Lite ports
    input                                     S_AXI_ACLK,
    input                                     S_AXI_ARESETN,
    input      [C_S_AXI_ADDR_WIDTH-1 : 0]     S_AXI_AWADDR,
    input                                     S_AXI_AWVALID,
    input      [C_S_AXI_DATA_WIDTH-1 : 0]     S_AXI_WDATA,
    input      [C_S_AXI_DATA_WIDTH/8-1 : 0]   S_AXI_WSTRB,
    input                                     S_AXI_WVALID,
    input                                     S_AXI_BREADY,
    input      [C_S_AXI_ADDR_WIDTH-1 : 0]     S_AXI_ARADDR,
    input                                     S_AXI_ARVALID,
    input                                     S_AXI_RREADY,
    output                                    S_AXI_ARREADY,
    output     [C_S_AXI_DATA_WIDTH-1 : 0]     S_AXI_RDATA,
    output     [1 : 0]                        S_AXI_RRESP,
    output                                    S_AXI_RVALID,
    output                                    S_AXI_WREADY,
    output     [1 :0]                         S_AXI_BRESP,
    output                                    S_AXI_BVALID,
    output                                    S_AXI_AWREADY

);

    // AXI4LITE signals
    reg [C_S_AXI_ADDR_WIDTH-1 : 0]      axi_awaddr;
    reg                                 axi_awready;
    reg                                 axi_wready;
    reg [1 : 0]                         axi_bresp;
    reg                                 axi_bvalid;
    reg [C_S_AXI_ADDR_WIDTH-1 : 0]      axi_araddr;
    reg                                 axi_arready;
    reg [C_S_AXI_DATA_WIDTH-1 : 0]      axi_rdata;
    reg [1 : 0]                         axi_rresp;
    reg                                 axi_rvalid;

    reg                                 resetn_sync_d;
    wire                                reg_rden;
    wire                                reg_wren;
    reg [C_S_AXI_DATA_WIDTH-1:0]        reg_data_out;
    integer                             byte_index;
    reg                                 pktin_reg_clear_d;
    reg                                 pktout_reg_clear_d;
    reg      [`REG_INDIRECTADDRESS_BITS] indirectaddress_reg;
    reg      [`REG_INDIRECTWRDATA_BITS] indirectwrdata_reg;
    reg      [`REG_INDIRECTREPLY_BITS] indirectreply_reg;
    reg      [`REG_INDIRECTCONFIG_BITS] indirectconfig_reg;
    reg      [`REG_INDIRECTCOMMAND_BITS] indirectcommand_reg;
    reg      [`REG_INDIRECTCOMMAND_BITS] indirectcommand_reg_internal;
    reg      indirectcommand_reg_update;

    // assign default little endian
    wire [C_S_AXI_DATA_WIDTH-1 : 0]     reg_patternmatch1_default_little;

    // assign default little endian
    wire [C_S_AXI_DATA_WIDTH-1 : 0]     reg_patternmatch2_default_little;

    // assign default little endian
    wire [C_S_AXI_DATA_WIDTH-1 : 0]     reg_patternmatch3_default_little;

    // assign default little endian
    wire [C_S_AXI_DATA_WIDTH-1 : 0]     reg_patternmatch4_default_little;

    // assign default little endian
    wire [C_S_AXI_DATA_WIDTH-1 : 0]     reg_patternmatch5_default_little;

    // assign default little endian
    wire [C_S_AXI_DATA_WIDTH-1 : 0]     reg_patternmatch6_default_little;

    // assign default little endian
    wire [C_S_AXI_DATA_WIDTH-1 : 0]     reg_patternmatch7_default_little;

    // assign default little endian
    wire [C_S_AXI_DATA_WIDTH-1 : 0]     reg_patternmatch8_default_little;

    // assign default little endian
    wire [C_S_AXI_DATA_WIDTH-1 : 0]     reg_patternmatch9_default_little;

    // assign default little endian
    wire [C_S_AXI_DATA_WIDTH-1 : 0]     reg_patternmatch10_default_little;

    // assign default little endian
    wire [C_S_AXI_DATA_WIDTH-1 : 0]     reg_patternmatch11_default_little;

    // assign default little endian
    wire [C_S_AXI_DATA_WIDTH-1 : 0]     reg_patternmatch12_default_little;

    // assign default little endian
    wire [C_S_AXI_DATA_WIDTH-1 : 0]     reg_patternmatch13_default_little;

    // assign default little endian
    wire [C_S_AXI_DATA_WIDTH-1 : 0]     reg_patternmatch14_default_little;

    // assign default little endian
    wire [C_S_AXI_DATA_WIDTH-1 : 0]     reg_patternmatch15_default_little;

    // assign default little endian
    wire [C_S_AXI_DATA_WIDTH-1 : 0]     reg_patternmatch16_default_little;

    // assign default little endian
    wire [C_S_AXI_DATA_WIDTH-1 : 0]     reg_patternmask1_default_little;

    // assign default little endian
    wire [C_S_AXI_DATA_WIDTH-1 : 0]     reg_patternmask2_default_little;

    // assign default little endian
    wire [C_S_AXI_DATA_WIDTH-1 : 0]     reg_patternmask3_default_little;

    // assign default little endian
    wire [C_S_AXI_DATA_WIDTH-1 : 0]     reg_patternmask4_default_little;

    // assign default little endian
    wire [C_S_AXI_DATA_WIDTH-1 : 0]     reg_patternmask5_default_little;

    // assign default little endian
    wire [C_S_AXI_DATA_WIDTH-1 : 0]     reg_patternmask6_default_little;

    // assign default little endian
    wire [C_S_AXI_DATA_WIDTH-1 : 0]     reg_patternmask7_default_little;

    // assign default little endian
    wire [C_S_AXI_DATA_WIDTH-1 : 0]     reg_patternmask8_default_little;

    // assign default little endian
    wire [C_S_AXI_DATA_WIDTH-1 : 0]     reg_patternmask9_default_little;

    // assign default little endian
    wire [C_S_AXI_DATA_WIDTH-1 : 0]     reg_patternmask10_default_little;

    // assign default little endian
    wire [C_S_AXI_DATA_WIDTH-1 : 0]     reg_patternmask11_default_little;

    // assign default little endian
    wire [C_S_AXI_DATA_WIDTH-1 : 0]     reg_patternmask12_default_little;

    // assign default little endian
    wire [C_S_AXI_DATA_WIDTH-1 : 0]     reg_patternmask13_default_little;

    // assign default little endian
    wire [C_S_AXI_DATA_WIDTH-1 : 0]     reg_patternmask14_default_little;

    // assign default little endian
    wire [C_S_AXI_DATA_WIDTH-1 : 0]     reg_patternmask15_default_little;

    // assign default little endian
    wire [C_S_AXI_DATA_WIDTH-1 : 0]     reg_patternmask16_default_little;
    assign  reg_patternmatch1_default_little = `REG_PATTERNMATCH1_DEFAULT;
    assign  reg_patternmatch2_default_little = `REG_PATTERNMATCH2_DEFAULT;
    assign  reg_patternmatch3_default_little = `REG_PATTERNMATCH3_DEFAULT;
    assign  reg_patternmatch4_default_little = `REG_PATTERNMATCH4_DEFAULT;
    assign  reg_patternmatch5_default_little = `REG_PATTERNMATCH5_DEFAULT;
    assign  reg_patternmatch6_default_little = `REG_PATTERNMATCH6_DEFAULT;
    assign  reg_patternmatch7_default_little = `REG_PATTERNMATCH7_DEFAULT;
    assign  reg_patternmatch8_default_little = `REG_PATTERNMATCH8_DEFAULT;
    assign  reg_patternmatch9_default_little = `REG_PATTERNMATCH9_DEFAULT;
    assign  reg_patternmatch10_default_little = `REG_PATTERNMATCH10_DEFAULT;
    assign  reg_patternmatch11_default_little = `REG_PATTERNMATCH11_DEFAULT;
    assign  reg_patternmatch12_default_little = `REG_PATTERNMATCH12_DEFAULT;
    assign  reg_patternmatch13_default_little = `REG_PATTERNMATCH13_DEFAULT;
    assign  reg_patternmatch14_default_little = `REG_PATTERNMATCH14_DEFAULT;
    assign  reg_patternmatch15_default_little = `REG_PATTERNMATCH15_DEFAULT;
    assign  reg_patternmatch16_default_little = `REG_PATTERNMATCH16_DEFAULT;
    assign  reg_patternmask1_default_little = `REG_PATTERNMASK1_DEFAULT;
    assign  reg_patternmask2_default_little = `REG_PATTERNMASK2_DEFAULT;
    assign  reg_patternmask3_default_little = `REG_PATTERNMASK3_DEFAULT;
    assign  reg_patternmask4_default_little = `REG_PATTERNMASK4_DEFAULT;
    assign  reg_patternmask5_default_little = `REG_PATTERNMASK5_DEFAULT;
    assign  reg_patternmask6_default_little = `REG_PATTERNMASK6_DEFAULT;
    assign  reg_patternmask7_default_little = `REG_PATTERNMASK7_DEFAULT;
    assign  reg_patternmask8_default_little = `REG_PATTERNMASK8_DEFAULT;
    assign  reg_patternmask9_default_little = `REG_PATTERNMASK9_DEFAULT;
    assign  reg_patternmask10_default_little = `REG_PATTERNMASK10_DEFAULT;
    assign  reg_patternmask11_default_little = `REG_PATTERNMASK11_DEFAULT;
    assign  reg_patternmask12_default_little = `REG_PATTERNMASK12_DEFAULT;
    assign  reg_patternmask13_default_little = `REG_PATTERNMASK13_DEFAULT;
    assign  reg_patternmask14_default_little = `REG_PATTERNMASK14_DEFAULT;
    assign  reg_patternmask15_default_little = `REG_PATTERNMASK15_DEFAULT;
    assign  reg_patternmask16_default_little = `REG_PATTERNMASK16_DEFAULT;

    // I/O Connections assignments
    assign S_AXI_AWREADY    = axi_awready;
    assign S_AXI_WREADY     = axi_wready;
    assign S_AXI_BRESP      = axi_bresp;
    assign S_AXI_BVALID     = axi_bvalid;
    assign S_AXI_ARREADY    = axi_arready;
    assign S_AXI_RDATA      = axi_rdata;
    assign S_AXI_RRESP      = axi_rresp;
    assign S_AXI_RVALID     = axi_rvalid;


    //Sample reset (not mandatory, but good practice)
    always @ (posedge clk) begin
        if (~resetn) begin
            resetn_sync_d  <=  1'b0;
            resetn_sync    <=  1'b0;
        end
        else begin
            resetn_sync_d  <=  resetn;
            resetn_sync    <=  resetn_sync_d;
        end
    end


    //global registers, sampling
    always @(posedge clk) resetn_soft <= #1 cpu_resetn_soft;

    // Implement axi_awready generation

    always @( posedge S_AXI_ACLK )
    begin
      if ( S_AXI_ARESETN == 1'b0 )
        begin
          axi_awready <= 1'b0;
        end
      else
        begin
          if (~axi_awready && S_AXI_AWVALID && S_AXI_WVALID)
            begin
              // slave is ready to accept write address when
              // there is a valid write address and write data
              // on the write address and data bus. This design
              // expects no outstanding transactions.
              axi_awready <= 1'b1;
            end
          else
            begin
              axi_awready <= 1'b0;
            end
        end
    end

    // Implement axi_awaddr latching

    always @( posedge S_AXI_ACLK )
    begin
      if ( S_AXI_ARESETN == 1'b0 )
        begin
          axi_awaddr <= 0;
        end
      else
        begin
          if (~axi_awready && S_AXI_AWVALID && S_AXI_WVALID)
            begin
              // Write Address latching
              axi_awaddr <= S_AXI_AWADDR ^ C_BASE_ADDRESS;
            end
        end
    end

    // Implement axi_wready generation

    always @( posedge S_AXI_ACLK )
    begin
      if ( S_AXI_ARESETN == 1'b0 )
        begin
          axi_wready <= 1'b0;
        end
      else
        begin
          if (~axi_wready && S_AXI_WVALID && S_AXI_AWVALID)
            begin
              // slave is ready to accept write data when
              // there is a valid write address and write data
              // on the write address and data bus. This design
              // expects no outstanding transactions.
              axi_wready <= 1'b1;
            end
          else
            begin
              axi_wready <= 1'b0;
            end
        end
    end

    // Implement write response logic generation

    always @( posedge S_AXI_ACLK )
    begin
      if ( S_AXI_ARESETN == 1'b0 )
        begin
          axi_bvalid  <= 0;
          axi_bresp   <= 2'b0;
        end
      else
        begin
          if (axi_awready && S_AXI_AWVALID && ~axi_bvalid && axi_wready && S_AXI_WVALID)
            begin
              // indicates a valid write response is available
              axi_bvalid <= 1'b1;
              axi_bresp  <= 2'b0; // OKAY response
            end                   // work error responses in future
          else
            begin
              if (S_AXI_BREADY && axi_bvalid)
                //check if bready is asserted while bvalid is high)
                //(there is a possibility that bready is always asserted high)
                begin
                  axi_bvalid <= 1'b0;
                end
            end
        end
    end

    // Implement axi_arready generation

    always @( posedge S_AXI_ACLK )
    begin
      if ( S_AXI_ARESETN == 1'b0 )
        begin
          axi_arready <= 1'b0;
          axi_araddr  <= 32'b0;
        end
      else
        begin
          if (~axi_arready && S_AXI_ARVALID)
            begin
              // indicates that the slave has acceped the valid read address
              // Read address latching
              axi_arready <= 1'b1;
              axi_araddr  <= S_AXI_ARADDR ^ C_BASE_ADDRESS;
            end
          else
            begin
              axi_arready <= 1'b0;
            end
        end
    end


    // Implement axi_rvalid generation

    always @( posedge S_AXI_ACLK )
    begin
      if ( S_AXI_ARESETN == 1'b0 )
        begin
          axi_rvalid <= 0;
          axi_rresp  <= 0;
        end
      else
        begin
          if (axi_arready && S_AXI_ARVALID && ~axi_rvalid)
            begin
              // Valid read data is available at the read data bus
              axi_rvalid <= 1'b1;
              axi_rresp  <= 2'b0; // OKAY response
            end
          else if (axi_rvalid && S_AXI_RREADY)
            begin
              // Read data is accepted by the master
              axi_rvalid <= 1'b0;
            end
        end
    end


    // Implement memory mapped register select and write logic generation

    assign reg_wren = axi_wready && S_AXI_WVALID && axi_awready && S_AXI_AWVALID;

//////////////////////////////////////////////////////////////
// write registers
//////////////////////////////////////////////////////////////


//Write only register, clear on write (i.e. event)
    always @(posedge clk) begin
        if (!resetn_sync) begin
            reset_reg <= #1 `REG_RESET_DEFAULT;
        end
        else begin
            if (reg_wren) begin
                case (axi_awaddr)
                    //Reset Register
                        `REG_RESET_ADDR : begin
                                for ( byte_index = 0; byte_index <= (`REG_RESET_WIDTH/8-1); byte_index = byte_index +1)
                                    if (S_AXI_WSTRB[byte_index] == 1) begin
                                        reset_reg[byte_index*8 +: 8] <=  S_AXI_WDATA[byte_index*8 +: 8];
                                    end
                        end
                endcase
            end
            else begin
                reset_reg <= #1 `REG_RESET_DEFAULT;
            end
        end
    end

//R/W register, not cleared
    always @(posedge clk) begin
        if (!resetn_sync) begin

            cpu2ip_flip_reg <= #1 `REG_FLIP_DEFAULT;
            cpu2ip_debug_reg <= #1 `REG_DEBUG_DEFAULT;
            cpu2ip_testtrigger_reg <= #1 `REG_TESTTRIGGER_DEFAULT;
            cpu2ip_bwgranularity_reg <= #1 `REG_BWGRANULARITY_DEFAULT;
            cpu2ip_bwdivisor_reg <= #1 `REG_BWDIVISOR_DEFAULT;
            cpu2ip_burstgap_reg <= #1 `REG_BURSTGAP_DEFAULT;
            cpu2ip_testend_reg <= #1 `REG_TESTEND_DEFAULT;
            cpu2ip_firsttime_reg <= #1 `REG_FIRSTTIME_DEFAULT;
            cpu2ip_lasttime_reg <= #1 `REG_LASTTIME_DEFAULT;
            cpu2ip_lastbw_reg <= #1 `REG_LASTBW_DEFAULT;
            inputsel_reg <= #1 `REG_INPUTSEL_DEFAULT;
            cpu2ip_arpcount_reg <= #1 `REG_ARPCOUNT_DEFAULT;
            cpu2ip_ip4count_reg <= #1 `REG_IP4COUNT_DEFAULT;
            cpu2ip_ip6count_reg <= #1 `REG_IP6COUNT_DEFAULT;
            cpu2ip_tcpcount_reg <= #1 `REG_TCPCOUNT_DEFAULT;
            cpu2ip_udpcount_reg <= #1 `REG_UDPCOUNT_DEFAULT;
            cpu2ip_syncount_reg <= #1 `REG_SYNCOUNT_DEFAULT;
            cpu2ip_fincount_reg <= #1 `REG_FINCOUNT_DEFAULT;
            cpu2ip_flowidcount_reg <= #1 `REG_FLOWIDCOUNT_DEFAULT;
            for (byte_index = 0; byte_index <= (`REG_PATTERNMATCH1_WIDTH/8-1); byte_index = byte_index +1)
                patternmatch1_reg[byte_index*8 +: 8] <= reg_patternmatch1_default_little[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            for (byte_index = 0; byte_index <= (`REG_PATTERNMATCH1_WIDTH/8-1); byte_index = byte_index +1)
                patternmatch1_reg[byte_index*8 +: 8] <= reg_patternmatch1_default_little[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            for (byte_index = 0; byte_index <= (`REG_PATTERNMATCH2_WIDTH/8-1); byte_index = byte_index +1)
                patternmatch2_reg[byte_index*8 +: 8] <= reg_patternmatch2_default_little[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            for (byte_index = 0; byte_index <= (`REG_PATTERNMATCH2_WIDTH/8-1); byte_index = byte_index +1)
                patternmatch2_reg[byte_index*8 +: 8] <= reg_patternmatch2_default_little[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            for (byte_index = 0; byte_index <= (`REG_PATTERNMATCH3_WIDTH/8-1); byte_index = byte_index +1)
                patternmatch3_reg[byte_index*8 +: 8] <= reg_patternmatch3_default_little[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            for (byte_index = 0; byte_index <= (`REG_PATTERNMATCH3_WIDTH/8-1); byte_index = byte_index +1)
                patternmatch3_reg[byte_index*8 +: 8] <= reg_patternmatch3_default_little[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            for (byte_index = 0; byte_index <= (`REG_PATTERNMATCH4_WIDTH/8-1); byte_index = byte_index +1)
                patternmatch4_reg[byte_index*8 +: 8] <= reg_patternmatch4_default_little[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            for (byte_index = 0; byte_index <= (`REG_PATTERNMATCH4_WIDTH/8-1); byte_index = byte_index +1)
                patternmatch4_reg[byte_index*8 +: 8] <= reg_patternmatch4_default_little[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            for (byte_index = 0; byte_index <= (`REG_PATTERNMATCH5_WIDTH/8-1); byte_index = byte_index +1)
                patternmatch5_reg[byte_index*8 +: 8] <= reg_patternmatch5_default_little[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            for (byte_index = 0; byte_index <= (`REG_PATTERNMATCH5_WIDTH/8-1); byte_index = byte_index +1)
                patternmatch5_reg[byte_index*8 +: 8] <= reg_patternmatch5_default_little[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            for (byte_index = 0; byte_index <= (`REG_PATTERNMATCH6_WIDTH/8-1); byte_index = byte_index +1)
                patternmatch6_reg[byte_index*8 +: 8] <= reg_patternmatch6_default_little[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            for (byte_index = 0; byte_index <= (`REG_PATTERNMATCH6_WIDTH/8-1); byte_index = byte_index +1)
                patternmatch6_reg[byte_index*8 +: 8] <= reg_patternmatch6_default_little[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            for (byte_index = 0; byte_index <= (`REG_PATTERNMATCH7_WIDTH/8-1); byte_index = byte_index +1)
                patternmatch7_reg[byte_index*8 +: 8] <= reg_patternmatch7_default_little[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            for (byte_index = 0; byte_index <= (`REG_PATTERNMATCH7_WIDTH/8-1); byte_index = byte_index +1)
                patternmatch7_reg[byte_index*8 +: 8] <= reg_patternmatch7_default_little[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            for (byte_index = 0; byte_index <= (`REG_PATTERNMATCH8_WIDTH/8-1); byte_index = byte_index +1)
                patternmatch8_reg[byte_index*8 +: 8] <= reg_patternmatch8_default_little[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            for (byte_index = 0; byte_index <= (`REG_PATTERNMATCH8_WIDTH/8-1); byte_index = byte_index +1)
                patternmatch8_reg[byte_index*8 +: 8] <= reg_patternmatch8_default_little[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            for (byte_index = 0; byte_index <= (`REG_PATTERNMATCH9_WIDTH/8-1); byte_index = byte_index +1)
                patternmatch9_reg[byte_index*8 +: 8] <= reg_patternmatch9_default_little[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            for (byte_index = 0; byte_index <= (`REG_PATTERNMATCH9_WIDTH/8-1); byte_index = byte_index +1)
                patternmatch9_reg[byte_index*8 +: 8] <= reg_patternmatch9_default_little[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            for (byte_index = 0; byte_index <= (`REG_PATTERNMATCH10_WIDTH/8-1); byte_index = byte_index +1)
                patternmatch10_reg[byte_index*8 +: 8] <= reg_patternmatch10_default_little[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            for (byte_index = 0; byte_index <= (`REG_PATTERNMATCH10_WIDTH/8-1); byte_index = byte_index +1)
                patternmatch10_reg[byte_index*8 +: 8] <= reg_patternmatch10_default_little[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            for (byte_index = 0; byte_index <= (`REG_PATTERNMATCH11_WIDTH/8-1); byte_index = byte_index +1)
                patternmatch11_reg[byte_index*8 +: 8] <= reg_patternmatch11_default_little[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            for (byte_index = 0; byte_index <= (`REG_PATTERNMATCH11_WIDTH/8-1); byte_index = byte_index +1)
                patternmatch11_reg[byte_index*8 +: 8] <= reg_patternmatch11_default_little[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            for (byte_index = 0; byte_index <= (`REG_PATTERNMATCH12_WIDTH/8-1); byte_index = byte_index +1)
                patternmatch12_reg[byte_index*8 +: 8] <= reg_patternmatch12_default_little[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            for (byte_index = 0; byte_index <= (`REG_PATTERNMATCH12_WIDTH/8-1); byte_index = byte_index +1)
                patternmatch12_reg[byte_index*8 +: 8] <= reg_patternmatch12_default_little[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            for (byte_index = 0; byte_index <= (`REG_PATTERNMATCH13_WIDTH/8-1); byte_index = byte_index +1)
                patternmatch13_reg[byte_index*8 +: 8] <= reg_patternmatch13_default_little[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            for (byte_index = 0; byte_index <= (`REG_PATTERNMATCH13_WIDTH/8-1); byte_index = byte_index +1)
                patternmatch13_reg[byte_index*8 +: 8] <= reg_patternmatch13_default_little[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            for (byte_index = 0; byte_index <= (`REG_PATTERNMATCH14_WIDTH/8-1); byte_index = byte_index +1)
                patternmatch14_reg[byte_index*8 +: 8] <= reg_patternmatch14_default_little[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            for (byte_index = 0; byte_index <= (`REG_PATTERNMATCH14_WIDTH/8-1); byte_index = byte_index +1)
                patternmatch14_reg[byte_index*8 +: 8] <= reg_patternmatch14_default_little[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            for (byte_index = 0; byte_index <= (`REG_PATTERNMATCH15_WIDTH/8-1); byte_index = byte_index +1)
                patternmatch15_reg[byte_index*8 +: 8] <= reg_patternmatch15_default_little[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            for (byte_index = 0; byte_index <= (`REG_PATTERNMATCH15_WIDTH/8-1); byte_index = byte_index +1)
                patternmatch15_reg[byte_index*8 +: 8] <= reg_patternmatch15_default_little[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            for (byte_index = 0; byte_index <= (`REG_PATTERNMATCH16_WIDTH/8-1); byte_index = byte_index +1)
                patternmatch16_reg[byte_index*8 +: 8] <= reg_patternmatch16_default_little[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            for (byte_index = 0; byte_index <= (`REG_PATTERNMATCH16_WIDTH/8-1); byte_index = byte_index +1)
                patternmatch16_reg[byte_index*8 +: 8] <= reg_patternmatch16_default_little[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            for (byte_index = 0; byte_index <= (`REG_PATTERNMASK1_WIDTH/8-1); byte_index = byte_index +1)
                patternmask1_reg[byte_index*8 +: 8] <= reg_patternmask1_default_little[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            for (byte_index = 0; byte_index <= (`REG_PATTERNMASK1_WIDTH/8-1); byte_index = byte_index +1)
                patternmask1_reg[byte_index*8 +: 8] <= reg_patternmask1_default_little[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            for (byte_index = 0; byte_index <= (`REG_PATTERNMASK2_WIDTH/8-1); byte_index = byte_index +1)
                patternmask2_reg[byte_index*8 +: 8] <= reg_patternmask2_default_little[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            for (byte_index = 0; byte_index <= (`REG_PATTERNMASK2_WIDTH/8-1); byte_index = byte_index +1)
                patternmask2_reg[byte_index*8 +: 8] <= reg_patternmask2_default_little[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            for (byte_index = 0; byte_index <= (`REG_PATTERNMASK3_WIDTH/8-1); byte_index = byte_index +1)
                patternmask3_reg[byte_index*8 +: 8] <= reg_patternmask3_default_little[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            for (byte_index = 0; byte_index <= (`REG_PATTERNMASK3_WIDTH/8-1); byte_index = byte_index +1)
                patternmask3_reg[byte_index*8 +: 8] <= reg_patternmask3_default_little[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            for (byte_index = 0; byte_index <= (`REG_PATTERNMASK4_WIDTH/8-1); byte_index = byte_index +1)
                patternmask4_reg[byte_index*8 +: 8] <= reg_patternmask4_default_little[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            for (byte_index = 0; byte_index <= (`REG_PATTERNMASK4_WIDTH/8-1); byte_index = byte_index +1)
                patternmask4_reg[byte_index*8 +: 8] <= reg_patternmask4_default_little[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            for (byte_index = 0; byte_index <= (`REG_PATTERNMASK5_WIDTH/8-1); byte_index = byte_index +1)
                patternmask5_reg[byte_index*8 +: 8] <= reg_patternmask5_default_little[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            for (byte_index = 0; byte_index <= (`REG_PATTERNMASK5_WIDTH/8-1); byte_index = byte_index +1)
                patternmask5_reg[byte_index*8 +: 8] <= reg_patternmask5_default_little[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            for (byte_index = 0; byte_index <= (`REG_PATTERNMASK6_WIDTH/8-1); byte_index = byte_index +1)
                patternmask6_reg[byte_index*8 +: 8] <= reg_patternmask6_default_little[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            for (byte_index = 0; byte_index <= (`REG_PATTERNMASK6_WIDTH/8-1); byte_index = byte_index +1)
                patternmask6_reg[byte_index*8 +: 8] <= reg_patternmask6_default_little[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            for (byte_index = 0; byte_index <= (`REG_PATTERNMASK7_WIDTH/8-1); byte_index = byte_index +1)
                patternmask7_reg[byte_index*8 +: 8] <= reg_patternmask7_default_little[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            for (byte_index = 0; byte_index <= (`REG_PATTERNMASK7_WIDTH/8-1); byte_index = byte_index +1)
                patternmask7_reg[byte_index*8 +: 8] <= reg_patternmask7_default_little[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            for (byte_index = 0; byte_index <= (`REG_PATTERNMASK8_WIDTH/8-1); byte_index = byte_index +1)
                patternmask8_reg[byte_index*8 +: 8] <= reg_patternmask8_default_little[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            for (byte_index = 0; byte_index <= (`REG_PATTERNMASK8_WIDTH/8-1); byte_index = byte_index +1)
                patternmask8_reg[byte_index*8 +: 8] <= reg_patternmask8_default_little[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            for (byte_index = 0; byte_index <= (`REG_PATTERNMASK9_WIDTH/8-1); byte_index = byte_index +1)
                patternmask9_reg[byte_index*8 +: 8] <= reg_patternmask9_default_little[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            for (byte_index = 0; byte_index <= (`REG_PATTERNMASK9_WIDTH/8-1); byte_index = byte_index +1)
                patternmask9_reg[byte_index*8 +: 8] <= reg_patternmask9_default_little[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            for (byte_index = 0; byte_index <= (`REG_PATTERNMASK10_WIDTH/8-1); byte_index = byte_index +1)
                patternmask10_reg[byte_index*8 +: 8] <= reg_patternmask10_default_little[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            for (byte_index = 0; byte_index <= (`REG_PATTERNMASK10_WIDTH/8-1); byte_index = byte_index +1)
                patternmask10_reg[byte_index*8 +: 8] <= reg_patternmask10_default_little[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            for (byte_index = 0; byte_index <= (`REG_PATTERNMASK11_WIDTH/8-1); byte_index = byte_index +1)
                patternmask11_reg[byte_index*8 +: 8] <= reg_patternmask11_default_little[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            for (byte_index = 0; byte_index <= (`REG_PATTERNMASK11_WIDTH/8-1); byte_index = byte_index +1)
                patternmask11_reg[byte_index*8 +: 8] <= reg_patternmask11_default_little[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            for (byte_index = 0; byte_index <= (`REG_PATTERNMASK12_WIDTH/8-1); byte_index = byte_index +1)
                patternmask12_reg[byte_index*8 +: 8] <= reg_patternmask12_default_little[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            for (byte_index = 0; byte_index <= (`REG_PATTERNMASK12_WIDTH/8-1); byte_index = byte_index +1)
                patternmask12_reg[byte_index*8 +: 8] <= reg_patternmask12_default_little[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            for (byte_index = 0; byte_index <= (`REG_PATTERNMASK13_WIDTH/8-1); byte_index = byte_index +1)
                patternmask13_reg[byte_index*8 +: 8] <= reg_patternmask13_default_little[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            for (byte_index = 0; byte_index <= (`REG_PATTERNMASK13_WIDTH/8-1); byte_index = byte_index +1)
                patternmask13_reg[byte_index*8 +: 8] <= reg_patternmask13_default_little[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            for (byte_index = 0; byte_index <= (`REG_PATTERNMASK14_WIDTH/8-1); byte_index = byte_index +1)
                patternmask14_reg[byte_index*8 +: 8] <= reg_patternmask14_default_little[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            for (byte_index = 0; byte_index <= (`REG_PATTERNMASK14_WIDTH/8-1); byte_index = byte_index +1)
                patternmask14_reg[byte_index*8 +: 8] <= reg_patternmask14_default_little[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            for (byte_index = 0; byte_index <= (`REG_PATTERNMASK15_WIDTH/8-1); byte_index = byte_index +1)
                patternmask15_reg[byte_index*8 +: 8] <= reg_patternmask15_default_little[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            for (byte_index = 0; byte_index <= (`REG_PATTERNMASK15_WIDTH/8-1); byte_index = byte_index +1)
                patternmask15_reg[byte_index*8 +: 8] <= reg_patternmask15_default_little[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            for (byte_index = 0; byte_index <= (`REG_PATTERNMASK16_WIDTH/8-1); byte_index = byte_index +1)
                patternmask16_reg[byte_index*8 +: 8] <= reg_patternmask16_default_little[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            for (byte_index = 0; byte_index <= (`REG_PATTERNMASK16_WIDTH/8-1); byte_index = byte_index +1)
                patternmask16_reg[byte_index*8 +: 8] <= reg_patternmask16_default_little[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            cpu2ip_matchcount_reg <= #1 `REG_MATCHCOUNT_DEFAULT;
            indirectaddress_reg <= #1 `REG_INDIRECTADDRESS_DEFAULT;
            indirectwrdata_reg <= #1 `REG_INDIRECTWRDATA_DEFAULT;
            indirectcommand_reg_internal <= #1 `REG_INDIRECTCOMMAND_DEFAULT;
            indirectconfig_reg <= #1 `REG_INDIRECTCONFIG_DEFAULT;
        end
        else begin
           if (reg_wren) //write event
            case (axi_awaddr)
            //Flip Register
                `REG_FLIP_ADDR : begin
                    for ( byte_index = 0; byte_index <= (`REG_FLIP_WIDTH/8-1); byte_index = byte_index +1)
                        if (S_AXI_WSTRB[byte_index] == 1) begin
                            cpu2ip_flip_reg[byte_index*8 +: 8] <=  S_AXI_WDATA[byte_index*8 +: 8]; //dynamic register;
                        end
                end
            //Debug Register
                `REG_DEBUG_ADDR : begin
                    for ( byte_index = 0; byte_index <= (`REG_DEBUG_WIDTH/8-1); byte_index = byte_index +1)
                        if (S_AXI_WSTRB[byte_index] == 1) begin
                            cpu2ip_debug_reg[byte_index*8 +: 8] <=  S_AXI_WDATA[byte_index*8 +: 8]; //dynamic register;
                        end
                end
            //Testtrigger Register
                `REG_TESTTRIGGER_ADDR : begin
                    for ( byte_index = 0; byte_index <= (`REG_TESTTRIGGER_WIDTH/8-1); byte_index = byte_index +1)
                        if (S_AXI_WSTRB[byte_index] == 1) begin
                            cpu2ip_testtrigger_reg[byte_index*8 +: 8] <=  S_AXI_WDATA[byte_index*8 +: 8]; //dynamic register;
                        end
                end
            //Bwgranularity Register
                `REG_BWGRANULARITY_ADDR : begin
                    for ( byte_index = 0; byte_index <= (`REG_BWGRANULARITY_WIDTH/8-1); byte_index = byte_index +1)
                        if (S_AXI_WSTRB[byte_index] == 1) begin
                            cpu2ip_bwgranularity_reg[byte_index*8 +: 8] <=  S_AXI_WDATA[byte_index*8 +: 8]; //dynamic register;
                        end
                end
            //Bwdivisor Register
                `REG_BWDIVISOR_ADDR : begin
                    for ( byte_index = 0; byte_index <= (`REG_BWDIVISOR_WIDTH/8-1); byte_index = byte_index +1)
                        if (S_AXI_WSTRB[byte_index] == 1) begin
                            cpu2ip_bwdivisor_reg[byte_index*8 +: 8] <=  S_AXI_WDATA[byte_index*8 +: 8]; //dynamic register;
                        end
                end
            //Burstgap Register
                `REG_BURSTGAP_ADDR : begin
                    for ( byte_index = 0; byte_index <= (`REG_BURSTGAP_WIDTH/8-1); byte_index = byte_index +1)
                        if (S_AXI_WSTRB[byte_index] == 1) begin
                            cpu2ip_burstgap_reg[byte_index*8 +: 8] <=  S_AXI_WDATA[byte_index*8 +: 8]; //dynamic register;
                        end
                end
            //Testend Register
                `REG_TESTEND_ADDR : begin
                    for ( byte_index = 0; byte_index <= (`REG_TESTEND_WIDTH/8-1); byte_index = byte_index +1)
                        if (S_AXI_WSTRB[byte_index] == 1) begin
                            cpu2ip_testend_reg[byte_index*8 +: 8] <=  S_AXI_WDATA[byte_index*8 +: 8]; //dynamic register;
                        end
                end
            //Firsttime Register
                `REG_FIRSTTIME_ADDR : begin
                    for ( byte_index = 0; byte_index <= (`REG_FIRSTTIME_WIDTH/8-1); byte_index = byte_index +1)
                        if (S_AXI_WSTRB[byte_index] == 1) begin
                            cpu2ip_firsttime_reg[byte_index*8 +: 8] <=  S_AXI_WDATA[byte_index*8 +: 8]; //dynamic register;
                        end
                end
            //Lasttime Register
                `REG_LASTTIME_ADDR : begin
                    for ( byte_index = 0; byte_index <= (`REG_LASTTIME_WIDTH/8-1); byte_index = byte_index +1)
                        if (S_AXI_WSTRB[byte_index] == 1) begin
                            cpu2ip_lasttime_reg[byte_index*8 +: 8] <=  S_AXI_WDATA[byte_index*8 +: 8]; //dynamic register;
                        end
                end
            //Lastbw Register
                `REG_LASTBW_ADDR : begin
                    for ( byte_index = 0; byte_index <= (`REG_LASTBW_WIDTH/8-1); byte_index = byte_index +1)
                        if (S_AXI_WSTRB[byte_index] == 1) begin
                            cpu2ip_lastbw_reg[byte_index*8 +: 8] <=  S_AXI_WDATA[byte_index*8 +: 8]; //dynamic register;
                        end
                end
            //Inputsel Register
                `REG_INPUTSEL_ADDR : begin
                    for ( byte_index = 0; byte_index <= (`REG_INPUTSEL_WIDTH/8-1); byte_index = byte_index +1)
                        if (S_AXI_WSTRB[byte_index] == 1) begin
                            inputsel_reg[byte_index*8 +: 8] <=  S_AXI_WDATA[byte_index*8 +: 8]; //static register;
                        end
                end
            //Arpcount Register
                `REG_ARPCOUNT_ADDR : begin
                    for ( byte_index = 0; byte_index <= (`REG_ARPCOUNT_WIDTH/8-1); byte_index = byte_index +1)
                        if (S_AXI_WSTRB[byte_index] == 1) begin
                            cpu2ip_arpcount_reg[byte_index*8 +: 8] <=  S_AXI_WDATA[byte_index*8 +: 8]; //dynamic register;
                        end
                end
            //Ip4count Register
                `REG_IP4COUNT_ADDR : begin
                    for ( byte_index = 0; byte_index <= (`REG_IP4COUNT_WIDTH/8-1); byte_index = byte_index +1)
                        if (S_AXI_WSTRB[byte_index] == 1) begin
                            cpu2ip_ip4count_reg[byte_index*8 +: 8] <=  S_AXI_WDATA[byte_index*8 +: 8]; //dynamic register;
                        end
                end
            //Ip6count Register
                `REG_IP6COUNT_ADDR : begin
                    for ( byte_index = 0; byte_index <= (`REG_IP6COUNT_WIDTH/8-1); byte_index = byte_index +1)
                        if (S_AXI_WSTRB[byte_index] == 1) begin
                            cpu2ip_ip6count_reg[byte_index*8 +: 8] <=  S_AXI_WDATA[byte_index*8 +: 8]; //dynamic register;
                        end
                end
            //Tcpcount Register
                `REG_TCPCOUNT_ADDR : begin
                    for ( byte_index = 0; byte_index <= (`REG_TCPCOUNT_WIDTH/8-1); byte_index = byte_index +1)
                        if (S_AXI_WSTRB[byte_index] == 1) begin
                            cpu2ip_tcpcount_reg[byte_index*8 +: 8] <=  S_AXI_WDATA[byte_index*8 +: 8]; //dynamic register;
                        end
                end
            //Udpcount Register
                `REG_UDPCOUNT_ADDR : begin
                    for ( byte_index = 0; byte_index <= (`REG_UDPCOUNT_WIDTH/8-1); byte_index = byte_index +1)
                        if (S_AXI_WSTRB[byte_index] == 1) begin
                            cpu2ip_udpcount_reg[byte_index*8 +: 8] <=  S_AXI_WDATA[byte_index*8 +: 8]; //dynamic register;
                        end
                end
            //Syncount Register
                `REG_SYNCOUNT_ADDR : begin
                    for ( byte_index = 0; byte_index <= (`REG_SYNCOUNT_WIDTH/8-1); byte_index = byte_index +1)
                        if (S_AXI_WSTRB[byte_index] == 1) begin
                            cpu2ip_syncount_reg[byte_index*8 +: 8] <=  S_AXI_WDATA[byte_index*8 +: 8]; //dynamic register;
                        end
                end
            //Fincount Register
                `REG_FINCOUNT_ADDR : begin
                    for ( byte_index = 0; byte_index <= (`REG_FINCOUNT_WIDTH/8-1); byte_index = byte_index +1)
                        if (S_AXI_WSTRB[byte_index] == 1) begin
                            cpu2ip_fincount_reg[byte_index*8 +: 8] <=  S_AXI_WDATA[byte_index*8 +: 8]; //dynamic register;
                        end
                end
            //Flowidcount Register
                `REG_FLOWIDCOUNT_ADDR : begin
                    for ( byte_index = 0; byte_index <= (`REG_FLOWIDCOUNT_WIDTH/8-1); byte_index = byte_index +1)
                        if (S_AXI_WSTRB[byte_index] == 1) begin
                            cpu2ip_flowidcount_reg[byte_index*8 +: 8] <=  S_AXI_WDATA[byte_index*8 +: 8]; //dynamic register;
                        end
                end
            //Patternmatch1 Register
                `REG_PATTERNMATCH1_ADDR : begin
                    for (byte_index = 0; byte_index <= (`REG_PATTERNMATCH1_WIDTH/8-1); byte_index = byte_index +1)
                        if (S_AXI_WSTRB[byte_index] == 1) begin
                            patternmatch1_reg[byte_index*8 +: 8] <= S_AXI_WDATA[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8]; //dynamic register;
                        end
                end
            //Patternmatch2 Register
                `REG_PATTERNMATCH2_ADDR : begin
                    for (byte_index = 0; byte_index <= (`REG_PATTERNMATCH2_WIDTH/8-1); byte_index = byte_index +1)
                        if (S_AXI_WSTRB[byte_index] == 1) begin
                            patternmatch2_reg[byte_index*8 +: 8] <= S_AXI_WDATA[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8]; //dynamic register;
                        end
                end
            //Patternmatch3 Register
                `REG_PATTERNMATCH3_ADDR : begin
                    for (byte_index = 0; byte_index <= (`REG_PATTERNMATCH3_WIDTH/8-1); byte_index = byte_index +1)
                        if (S_AXI_WSTRB[byte_index] == 1) begin
                            patternmatch3_reg[byte_index*8 +: 8] <= S_AXI_WDATA[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8]; //dynamic register;
                        end
                end
            //Patternmatch4 Register
                `REG_PATTERNMATCH4_ADDR : begin
                    for (byte_index = 0; byte_index <= (`REG_PATTERNMATCH4_WIDTH/8-1); byte_index = byte_index +1)
                        if (S_AXI_WSTRB[byte_index] == 1) begin
                            patternmatch4_reg[byte_index*8 +: 8] <= S_AXI_WDATA[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8]; //dynamic register;
                        end
                end
            //Patternmatch5 Register
                `REG_PATTERNMATCH5_ADDR : begin
                    for (byte_index = 0; byte_index <= (`REG_PATTERNMATCH5_WIDTH/8-1); byte_index = byte_index +1)
                        if (S_AXI_WSTRB[byte_index] == 1) begin
                            patternmatch5_reg[byte_index*8 +: 8] <= S_AXI_WDATA[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8]; //dynamic register;
                        end
                end
            //Patternmatch6 Register
                `REG_PATTERNMATCH6_ADDR : begin
                    for (byte_index = 0; byte_index <= (`REG_PATTERNMATCH6_WIDTH/8-1); byte_index = byte_index +1)
                        if (S_AXI_WSTRB[byte_index] == 1) begin
                            patternmatch6_reg[byte_index*8 +: 8] <= S_AXI_WDATA[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8]; //dynamic register;
                        end
                end
            //Patternmatch7 Register
                `REG_PATTERNMATCH7_ADDR : begin
                    for (byte_index = 0; byte_index <= (`REG_PATTERNMATCH7_WIDTH/8-1); byte_index = byte_index +1)
                        if (S_AXI_WSTRB[byte_index] == 1) begin
                            patternmatch7_reg[byte_index*8 +: 8] <= S_AXI_WDATA[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8]; //dynamic register;
                        end
                end
            //Patternmatch8 Register
                `REG_PATTERNMATCH8_ADDR : begin
                    for (byte_index = 0; byte_index <= (`REG_PATTERNMATCH8_WIDTH/8-1); byte_index = byte_index +1)
                        if (S_AXI_WSTRB[byte_index] == 1) begin
                            patternmatch8_reg[byte_index*8 +: 8] <= S_AXI_WDATA[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8]; //dynamic register;
                        end
                end
            //Patternmatch9 Register
                `REG_PATTERNMATCH9_ADDR : begin
                    for (byte_index = 0; byte_index <= (`REG_PATTERNMATCH9_WIDTH/8-1); byte_index = byte_index +1)
                        if (S_AXI_WSTRB[byte_index] == 1) begin
                            patternmatch9_reg[byte_index*8 +: 8] <= S_AXI_WDATA[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8]; //dynamic register;
                        end
                end
            //Patternmatch10 Register
                `REG_PATTERNMATCH10_ADDR : begin
                    for (byte_index = 0; byte_index <= (`REG_PATTERNMATCH10_WIDTH/8-1); byte_index = byte_index +1)
                        if (S_AXI_WSTRB[byte_index] == 1) begin
                            patternmatch10_reg[byte_index*8 +: 8] <= S_AXI_WDATA[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8]; //dynamic register;
                        end
                end
            //Patternmatch11 Register
                `REG_PATTERNMATCH11_ADDR : begin
                    for (byte_index = 0; byte_index <= (`REG_PATTERNMATCH11_WIDTH/8-1); byte_index = byte_index +1)
                        if (S_AXI_WSTRB[byte_index] == 1) begin
                            patternmatch11_reg[byte_index*8 +: 8] <= S_AXI_WDATA[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8]; //dynamic register;
                        end
                end
            //Patternmatch12 Register
                `REG_PATTERNMATCH12_ADDR : begin
                    for (byte_index = 0; byte_index <= (`REG_PATTERNMATCH12_WIDTH/8-1); byte_index = byte_index +1)
                        if (S_AXI_WSTRB[byte_index] == 1) begin
                            patternmatch12_reg[byte_index*8 +: 8] <= S_AXI_WDATA[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8]; //dynamic register;
                        end
                end
            //Patternmatch13 Register
                `REG_PATTERNMATCH13_ADDR : begin
                    for (byte_index = 0; byte_index <= (`REG_PATTERNMATCH13_WIDTH/8-1); byte_index = byte_index +1)
                        if (S_AXI_WSTRB[byte_index] == 1) begin
                            patternmatch13_reg[byte_index*8 +: 8] <= S_AXI_WDATA[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8]; //dynamic register;
                        end
                end
            //Patternmatch14 Register
                `REG_PATTERNMATCH14_ADDR : begin
                    for (byte_index = 0; byte_index <= (`REG_PATTERNMATCH14_WIDTH/8-1); byte_index = byte_index +1)
                        if (S_AXI_WSTRB[byte_index] == 1) begin
                            patternmatch14_reg[byte_index*8 +: 8] <= S_AXI_WDATA[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8]; //dynamic register;
                        end
                end
            //Patternmatch15 Register
                `REG_PATTERNMATCH15_ADDR : begin
                    for (byte_index = 0; byte_index <= (`REG_PATTERNMATCH15_WIDTH/8-1); byte_index = byte_index +1)
                        if (S_AXI_WSTRB[byte_index] == 1) begin
                            patternmatch15_reg[byte_index*8 +: 8] <= S_AXI_WDATA[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8]; //dynamic register;
                        end
                end
            //Patternmatch16 Register
                `REG_PATTERNMATCH16_ADDR : begin
                    for (byte_index = 0; byte_index <= (`REG_PATTERNMATCH16_WIDTH/8-1); byte_index = byte_index +1)
                        if (S_AXI_WSTRB[byte_index] == 1) begin
                            patternmatch16_reg[byte_index*8 +: 8] <= S_AXI_WDATA[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8]; //dynamic register;
                        end
                end
            //Patternmask1 Register
                `REG_PATTERNMASK1_ADDR : begin
                    for (byte_index = 0; byte_index <= (`REG_PATTERNMASK1_WIDTH/8-1); byte_index = byte_index +1)
                        if (S_AXI_WSTRB[byte_index] == 1) begin
                            patternmask1_reg[byte_index*8 +: 8] <= S_AXI_WDATA[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8]; //dynamic register;
                        end
                end
            //Patternmask2 Register
                `REG_PATTERNMASK2_ADDR : begin
                    for (byte_index = 0; byte_index <= (`REG_PATTERNMASK2_WIDTH/8-1); byte_index = byte_index +1)
                        if (S_AXI_WSTRB[byte_index] == 1) begin
                            patternmask2_reg[byte_index*8 +: 8] <= S_AXI_WDATA[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8]; //dynamic register;
                        end
                end
            //Patternmask3 Register
                `REG_PATTERNMASK3_ADDR : begin
                    for (byte_index = 0; byte_index <= (`REG_PATTERNMASK3_WIDTH/8-1); byte_index = byte_index +1)
                        if (S_AXI_WSTRB[byte_index] == 1) begin
                            patternmask3_reg[byte_index*8 +: 8] <= S_AXI_WDATA[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8]; //dynamic register;
                        end
                end
            //Patternmask4 Register
                `REG_PATTERNMASK4_ADDR : begin
                    for (byte_index = 0; byte_index <= (`REG_PATTERNMASK4_WIDTH/8-1); byte_index = byte_index +1)
                        if (S_AXI_WSTRB[byte_index] == 1) begin
                            patternmask4_reg[byte_index*8 +: 8] <= S_AXI_WDATA[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8]; //dynamic register;
                        end
                end
            //Patternmask5 Register
                `REG_PATTERNMASK5_ADDR : begin
                    for (byte_index = 0; byte_index <= (`REG_PATTERNMASK5_WIDTH/8-1); byte_index = byte_index +1)
                        if (S_AXI_WSTRB[byte_index] == 1) begin
                            patternmask5_reg[byte_index*8 +: 8] <= S_AXI_WDATA[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8]; //dynamic register;
                        end
                end
            //Patternmask6 Register
                `REG_PATTERNMASK6_ADDR : begin
                    for (byte_index = 0; byte_index <= (`REG_PATTERNMASK6_WIDTH/8-1); byte_index = byte_index +1)
                        if (S_AXI_WSTRB[byte_index] == 1) begin
                            patternmask6_reg[byte_index*8 +: 8] <= S_AXI_WDATA[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8]; //dynamic register;
                        end
                end
            //Patternmask7 Register
                `REG_PATTERNMASK7_ADDR : begin
                    for (byte_index = 0; byte_index <= (`REG_PATTERNMASK7_WIDTH/8-1); byte_index = byte_index +1)
                        if (S_AXI_WSTRB[byte_index] == 1) begin
                            patternmask7_reg[byte_index*8 +: 8] <= S_AXI_WDATA[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8]; //dynamic register;
                        end
                end
            //Patternmask8 Register
                `REG_PATTERNMASK8_ADDR : begin
                    for (byte_index = 0; byte_index <= (`REG_PATTERNMASK8_WIDTH/8-1); byte_index = byte_index +1)
                        if (S_AXI_WSTRB[byte_index] == 1) begin
                            patternmask8_reg[byte_index*8 +: 8] <= S_AXI_WDATA[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8]; //dynamic register;
                        end
                end
            //Patternmask9 Register
                `REG_PATTERNMASK9_ADDR : begin
                    for (byte_index = 0; byte_index <= (`REG_PATTERNMASK9_WIDTH/8-1); byte_index = byte_index +1)
                        if (S_AXI_WSTRB[byte_index] == 1) begin
                            patternmask9_reg[byte_index*8 +: 8] <= S_AXI_WDATA[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8]; //dynamic register;
                        end
                end
            //Patternmask10 Register
                `REG_PATTERNMASK10_ADDR : begin
                    for (byte_index = 0; byte_index <= (`REG_PATTERNMASK10_WIDTH/8-1); byte_index = byte_index +1)
                        if (S_AXI_WSTRB[byte_index] == 1) begin
                            patternmask10_reg[byte_index*8 +: 8] <= S_AXI_WDATA[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8]; //dynamic register;
                        end
                end
            //Patternmask11 Register
                `REG_PATTERNMASK11_ADDR : begin
                    for (byte_index = 0; byte_index <= (`REG_PATTERNMASK11_WIDTH/8-1); byte_index = byte_index +1)
                        if (S_AXI_WSTRB[byte_index] == 1) begin
                            patternmask11_reg[byte_index*8 +: 8] <= S_AXI_WDATA[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8]; //dynamic register;
                        end
                end
            //Patternmask12 Register
                `REG_PATTERNMASK12_ADDR : begin
                    for (byte_index = 0; byte_index <= (`REG_PATTERNMASK12_WIDTH/8-1); byte_index = byte_index +1)
                        if (S_AXI_WSTRB[byte_index] == 1) begin
                            patternmask12_reg[byte_index*8 +: 8] <= S_AXI_WDATA[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8]; //dynamic register;
                        end
                end
            //Patternmask13 Register
                `REG_PATTERNMASK13_ADDR : begin
                    for (byte_index = 0; byte_index <= (`REG_PATTERNMASK13_WIDTH/8-1); byte_index = byte_index +1)
                        if (S_AXI_WSTRB[byte_index] == 1) begin
                            patternmask13_reg[byte_index*8 +: 8] <= S_AXI_WDATA[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8]; //dynamic register;
                        end
                end
            //Patternmask14 Register
                `REG_PATTERNMASK14_ADDR : begin
                    for (byte_index = 0; byte_index <= (`REG_PATTERNMASK14_WIDTH/8-1); byte_index = byte_index +1)
                        if (S_AXI_WSTRB[byte_index] == 1) begin
                            patternmask14_reg[byte_index*8 +: 8] <= S_AXI_WDATA[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8]; //dynamic register;
                        end
                end
            //Patternmask15 Register
                `REG_PATTERNMASK15_ADDR : begin
                    for (byte_index = 0; byte_index <= (`REG_PATTERNMASK15_WIDTH/8-1); byte_index = byte_index +1)
                        if (S_AXI_WSTRB[byte_index] == 1) begin
                            patternmask15_reg[byte_index*8 +: 8] <= S_AXI_WDATA[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8]; //dynamic register;
                        end
                end
            //Patternmask16 Register
                `REG_PATTERNMASK16_ADDR : begin
                    for (byte_index = 0; byte_index <= (`REG_PATTERNMASK16_WIDTH/8-1); byte_index = byte_index +1)
                        if (S_AXI_WSTRB[byte_index] == 1) begin
                            patternmask16_reg[byte_index*8 +: 8] <= S_AXI_WDATA[(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8]; //dynamic register;
                        end
                end
            //Matchcount Register
                `REG_MATCHCOUNT_ADDR : begin
                    for ( byte_index = 0; byte_index <= (`REG_MATCHCOUNT_WIDTH/8-1); byte_index = byte_index +1)
                        if (S_AXI_WSTRB[byte_index] == 1) begin
                            cpu2ip_matchcount_reg[byte_index*8 +: 8] <=  S_AXI_WDATA[byte_index*8 +: 8]; //dynamic register;
                        end
                end
            //Indirectaddress Register
                `REG_INDIRECTADDRESS_ADDR : begin
                    for ( byte_index = 0; byte_index <= (`REG_INDIRECTADDRESS_WIDTH/8-1); byte_index = byte_index +1)
                        if (S_AXI_WSTRB[byte_index] == 1) begin
                            indirectaddress_reg[byte_index*8 +: 8] <=  S_AXI_WDATA[byte_index*8 +: 8]; //static register;
                        end
                end
            //Indirectwrdata Register
                `REG_INDIRECTWRDATA_ADDR : begin
                    for ( byte_index = 0; byte_index <= (`REG_INDIRECTWRDATA_WIDTH/8-1); byte_index = byte_index +1)
                        if (S_AXI_WSTRB[byte_index] == 1) begin
                            indirectwrdata_reg[byte_index*8 +: 8] <=  S_AXI_WDATA[byte_index*8 +: 8]; //static register;
                        end
                end
            //Indirectcommand Register
                `REG_INDIRECTCOMMAND_ADDR : begin
                    for ( byte_index = 0; byte_index <= (`REG_INDIRECTCOMMAND_WIDTH/8-1); byte_index = byte_index +1)
                        if (S_AXI_WSTRB[byte_index] == 1) begin
                            indirectcommand_reg_internal[byte_index*8 +: 8] <=  S_AXI_WDATA[byte_index*8 +: 8]; //static register;
                        end
                end
            //Indirectconfig Register
                `REG_INDIRECTCONFIG_ADDR : begin
                    for ( byte_index = 0; byte_index <= (`REG_INDIRECTCONFIG_WIDTH/8-1); byte_index = byte_index +1)
                        if (S_AXI_WSTRB[byte_index] == 1) begin
                            indirectconfig_reg[byte_index*8 +: 8] <=  S_AXI_WDATA[byte_index*8 +: 8]; //static register;
                        end
                end
                default: begin
                end

            endcase
        end
   indirectcommand_reg_update <= reg_wren && (axi_awaddr == `REG_INDIRECTCOMMAND_ADDR);
  end



/////////////////////////
//// end of write
/////////////////////////

    // Implement memory mapped register select and read logic generation
    // Slave register read enable is asserted when valid address is available
    // and the slave is ready to accept the read address.

    // reg_rden control logic
    // temperary no extra logic here
    assign reg_rden = axi_arready & S_AXI_ARVALID & ~axi_rvalid;

    always @(*)
    begin

        case ( axi_araddr /*S_AXI_ARADDR ^ C_BASE_ADDRESS*/)
            //Id Register
            `REG_ID_ADDR : begin
                reg_data_out [`REG_ID_BITS] =  id_reg;
            end
            //Version Register
            `REG_VERSION_ADDR : begin
                reg_data_out [`REG_VERSION_BITS] =  version_reg;
            end
            //Flip Register
            `REG_FLIP_ADDR : begin
                reg_data_out [`REG_FLIP_BITS] =  ip2cpu_flip_reg;
            end
            //Debug Register
            `REG_DEBUG_ADDR : begin
                reg_data_out [`REG_DEBUG_BITS] =  ip2cpu_debug_reg;
            end
            //Pktin Register
            `REG_PKTIN_ADDR : begin
                reg_data_out [`REG_PKTIN_BITS] =  pktin_reg;
            end
            //Pktout Register
            `REG_PKTOUT_ADDR : begin
                reg_data_out [`REG_PKTOUT_BITS] =  pktout_reg;
            end
            //Testtrigger Register
            `REG_TESTTRIGGER_ADDR : begin
                reg_data_out [`REG_TESTTRIGGER_BITS] =  ip2cpu_testtrigger_reg;
            end
            //Bwgranularity Register
            `REG_BWGRANULARITY_ADDR : begin
                reg_data_out [`REG_BWGRANULARITY_BITS] =  ip2cpu_bwgranularity_reg;
            end
            //Bwdivisor Register
            `REG_BWDIVISOR_ADDR : begin
                reg_data_out [`REG_BWDIVISOR_BITS] =  ip2cpu_bwdivisor_reg;
            end
            //Burstgap Register
            `REG_BURSTGAP_ADDR : begin
                reg_data_out [`REG_BURSTGAP_BITS] =  ip2cpu_burstgap_reg;
            end
            //Testend Register
            `REG_TESTEND_ADDR : begin
                reg_data_out [`REG_TESTEND_BITS] =  ip2cpu_testend_reg;
            end
            //Firsttime Register
            `REG_FIRSTTIME_ADDR : begin
                reg_data_out [`REG_FIRSTTIME_BITS] =  ip2cpu_firsttime_reg;
            end
            //Lasttime Register
            `REG_LASTTIME_ADDR : begin
                reg_data_out [`REG_LASTTIME_BITS] =  ip2cpu_lasttime_reg;
            end
            //Lastbw Register
            `REG_LASTBW_ADDR : begin
                reg_data_out [`REG_LASTBW_BITS] =  ip2cpu_lastbw_reg;
            end
            //Inputsel Register
            `REG_INPUTSEL_ADDR : begin
                reg_data_out [`REG_INPUTSEL_BITS] =  inputsel_reg;
            end
            //Arpcount Register
            `REG_ARPCOUNT_ADDR : begin
                reg_data_out [`REG_ARPCOUNT_BITS] =  ip2cpu_arpcount_reg;
            end
            //Ip4count Register
            `REG_IP4COUNT_ADDR : begin
                reg_data_out [`REG_IP4COUNT_BITS] =  ip2cpu_ip4count_reg;
            end
            //Ip6count Register
            `REG_IP6COUNT_ADDR : begin
                reg_data_out [`REG_IP6COUNT_BITS] =  ip2cpu_ip6count_reg;
            end
            //Tcpcount Register
            `REG_TCPCOUNT_ADDR : begin
                reg_data_out [`REG_TCPCOUNT_BITS] =  ip2cpu_tcpcount_reg;
            end
            //Udpcount Register
            `REG_UDPCOUNT_ADDR : begin
                reg_data_out [`REG_UDPCOUNT_BITS] =  ip2cpu_udpcount_reg;
            end
            //Syncount Register
            `REG_SYNCOUNT_ADDR : begin
                reg_data_out [`REG_SYNCOUNT_BITS] =  ip2cpu_syncount_reg;
            end
            //Fincount Register
            `REG_FINCOUNT_ADDR : begin
                reg_data_out [`REG_FINCOUNT_BITS] =  ip2cpu_fincount_reg;
            end
            //Flowidcount Register
            `REG_FLOWIDCOUNT_ADDR : begin
                reg_data_out [`REG_FLOWIDCOUNT_BITS] =  ip2cpu_flowidcount_reg;
            end
            //Patternmatch1 Register
            `REG_PATTERNMATCH1_ADDR : begin
                for (byte_index = 0; byte_index <= (`REG_PATTERNMATCH1_WIDTH/8-1); byte_index = byte_index +1)
                    reg_data_out [byte_index*8 +: 8] = patternmatch1_reg [(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            end
            //Patternmatch2 Register
            `REG_PATTERNMATCH2_ADDR : begin
                for (byte_index = 0; byte_index <= (`REG_PATTERNMATCH2_WIDTH/8-1); byte_index = byte_index +1)
                    reg_data_out [byte_index*8 +: 8] = patternmatch2_reg [(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            end
            //Patternmatch3 Register
            `REG_PATTERNMATCH3_ADDR : begin
                for (byte_index = 0; byte_index <= (`REG_PATTERNMATCH3_WIDTH/8-1); byte_index = byte_index +1)
                    reg_data_out [byte_index*8 +: 8] = patternmatch3_reg [(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            end
            //Patternmatch4 Register
            `REG_PATTERNMATCH4_ADDR : begin
                for (byte_index = 0; byte_index <= (`REG_PATTERNMATCH4_WIDTH/8-1); byte_index = byte_index +1)
                    reg_data_out [byte_index*8 +: 8] = patternmatch4_reg [(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            end
            //Patternmatch5 Register
            `REG_PATTERNMATCH5_ADDR : begin
                for (byte_index = 0; byte_index <= (`REG_PATTERNMATCH5_WIDTH/8-1); byte_index = byte_index +1)
                    reg_data_out [byte_index*8 +: 8] = patternmatch5_reg [(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            end
            //Patternmatch6 Register
            `REG_PATTERNMATCH6_ADDR : begin
                for (byte_index = 0; byte_index <= (`REG_PATTERNMATCH6_WIDTH/8-1); byte_index = byte_index +1)
                    reg_data_out [byte_index*8 +: 8] = patternmatch6_reg [(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            end
            //Patternmatch7 Register
            `REG_PATTERNMATCH7_ADDR : begin
                for (byte_index = 0; byte_index <= (`REG_PATTERNMATCH7_WIDTH/8-1); byte_index = byte_index +1)
                    reg_data_out [byte_index*8 +: 8] = patternmatch7_reg [(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            end
            //Patternmatch8 Register
            `REG_PATTERNMATCH8_ADDR : begin
                for (byte_index = 0; byte_index <= (`REG_PATTERNMATCH8_WIDTH/8-1); byte_index = byte_index +1)
                    reg_data_out [byte_index*8 +: 8] = patternmatch8_reg [(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            end
            //Patternmatch9 Register
            `REG_PATTERNMATCH9_ADDR : begin
                for (byte_index = 0; byte_index <= (`REG_PATTERNMATCH9_WIDTH/8-1); byte_index = byte_index +1)
                    reg_data_out [byte_index*8 +: 8] = patternmatch9_reg [(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            end
            //Patternmatch10 Register
            `REG_PATTERNMATCH10_ADDR : begin
                for (byte_index = 0; byte_index <= (`REG_PATTERNMATCH10_WIDTH/8-1); byte_index = byte_index +1)
                    reg_data_out [byte_index*8 +: 8] = patternmatch10_reg [(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            end
            //Patternmatch11 Register
            `REG_PATTERNMATCH11_ADDR : begin
                for (byte_index = 0; byte_index <= (`REG_PATTERNMATCH11_WIDTH/8-1); byte_index = byte_index +1)
                    reg_data_out [byte_index*8 +: 8] = patternmatch11_reg [(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            end
            //Patternmatch12 Register
            `REG_PATTERNMATCH12_ADDR : begin
                for (byte_index = 0; byte_index <= (`REG_PATTERNMATCH12_WIDTH/8-1); byte_index = byte_index +1)
                    reg_data_out [byte_index*8 +: 8] = patternmatch12_reg [(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            end
            //Patternmatch13 Register
            `REG_PATTERNMATCH13_ADDR : begin
                for (byte_index = 0; byte_index <= (`REG_PATTERNMATCH13_WIDTH/8-1); byte_index = byte_index +1)
                    reg_data_out [byte_index*8 +: 8] = patternmatch13_reg [(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            end
            //Patternmatch14 Register
            `REG_PATTERNMATCH14_ADDR : begin
                for (byte_index = 0; byte_index <= (`REG_PATTERNMATCH14_WIDTH/8-1); byte_index = byte_index +1)
                    reg_data_out [byte_index*8 +: 8] = patternmatch14_reg [(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            end
            //Patternmatch15 Register
            `REG_PATTERNMATCH15_ADDR : begin
                for (byte_index = 0; byte_index <= (`REG_PATTERNMATCH15_WIDTH/8-1); byte_index = byte_index +1)
                    reg_data_out [byte_index*8 +: 8] = patternmatch15_reg [(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            end
            //Patternmatch16 Register
            `REG_PATTERNMATCH16_ADDR : begin
                for (byte_index = 0; byte_index <= (`REG_PATTERNMATCH16_WIDTH/8-1); byte_index = byte_index +1)
                    reg_data_out [byte_index*8 +: 8] = patternmatch16_reg [(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            end
            //Patternmask1 Register
            `REG_PATTERNMASK1_ADDR : begin
                for (byte_index = 0; byte_index <= (`REG_PATTERNMASK1_WIDTH/8-1); byte_index = byte_index +1)
                    reg_data_out [byte_index*8 +: 8] = patternmask1_reg [(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            end
            //Patternmask2 Register
            `REG_PATTERNMASK2_ADDR : begin
                for (byte_index = 0; byte_index <= (`REG_PATTERNMASK2_WIDTH/8-1); byte_index = byte_index +1)
                    reg_data_out [byte_index*8 +: 8] = patternmask2_reg [(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            end
            //Patternmask3 Register
            `REG_PATTERNMASK3_ADDR : begin
                for (byte_index = 0; byte_index <= (`REG_PATTERNMASK3_WIDTH/8-1); byte_index = byte_index +1)
                    reg_data_out [byte_index*8 +: 8] = patternmask3_reg [(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            end
            //Patternmask4 Register
            `REG_PATTERNMASK4_ADDR : begin
                for (byte_index = 0; byte_index <= (`REG_PATTERNMASK4_WIDTH/8-1); byte_index = byte_index +1)
                    reg_data_out [byte_index*8 +: 8] = patternmask4_reg [(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            end
            //Patternmask5 Register
            `REG_PATTERNMASK5_ADDR : begin
                for (byte_index = 0; byte_index <= (`REG_PATTERNMASK5_WIDTH/8-1); byte_index = byte_index +1)
                    reg_data_out [byte_index*8 +: 8] = patternmask5_reg [(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            end
            //Patternmask6 Register
            `REG_PATTERNMASK6_ADDR : begin
                for (byte_index = 0; byte_index <= (`REG_PATTERNMASK6_WIDTH/8-1); byte_index = byte_index +1)
                    reg_data_out [byte_index*8 +: 8] = patternmask6_reg [(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            end
            //Patternmask7 Register
            `REG_PATTERNMASK7_ADDR : begin
                for (byte_index = 0; byte_index <= (`REG_PATTERNMASK7_WIDTH/8-1); byte_index = byte_index +1)
                    reg_data_out [byte_index*8 +: 8] = patternmask7_reg [(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            end
            //Patternmask8 Register
            `REG_PATTERNMASK8_ADDR : begin
                for (byte_index = 0; byte_index <= (`REG_PATTERNMASK8_WIDTH/8-1); byte_index = byte_index +1)
                    reg_data_out [byte_index*8 +: 8] = patternmask8_reg [(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            end
            //Patternmask9 Register
            `REG_PATTERNMASK9_ADDR : begin
                for (byte_index = 0; byte_index <= (`REG_PATTERNMASK9_WIDTH/8-1); byte_index = byte_index +1)
                    reg_data_out [byte_index*8 +: 8] = patternmask9_reg [(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            end
            //Patternmask10 Register
            `REG_PATTERNMASK10_ADDR : begin
                for (byte_index = 0; byte_index <= (`REG_PATTERNMASK10_WIDTH/8-1); byte_index = byte_index +1)
                    reg_data_out [byte_index*8 +: 8] = patternmask10_reg [(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            end
            //Patternmask11 Register
            `REG_PATTERNMASK11_ADDR : begin
                for (byte_index = 0; byte_index <= (`REG_PATTERNMASK11_WIDTH/8-1); byte_index = byte_index +1)
                    reg_data_out [byte_index*8 +: 8] = patternmask11_reg [(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            end
            //Patternmask12 Register
            `REG_PATTERNMASK12_ADDR : begin
                for (byte_index = 0; byte_index <= (`REG_PATTERNMASK12_WIDTH/8-1); byte_index = byte_index +1)
                    reg_data_out [byte_index*8 +: 8] = patternmask12_reg [(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            end
            //Patternmask13 Register
            `REG_PATTERNMASK13_ADDR : begin
                for (byte_index = 0; byte_index <= (`REG_PATTERNMASK13_WIDTH/8-1); byte_index = byte_index +1)
                    reg_data_out [byte_index*8 +: 8] = patternmask13_reg [(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            end
            //Patternmask14 Register
            `REG_PATTERNMASK14_ADDR : begin
                for (byte_index = 0; byte_index <= (`REG_PATTERNMASK14_WIDTH/8-1); byte_index = byte_index +1)
                    reg_data_out [byte_index*8 +: 8] = patternmask14_reg [(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            end
            //Patternmask15 Register
            `REG_PATTERNMASK15_ADDR : begin
                for (byte_index = 0; byte_index <= (`REG_PATTERNMASK15_WIDTH/8-1); byte_index = byte_index +1)
                    reg_data_out [byte_index*8 +: 8] = patternmask15_reg [(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            end
            //Patternmask16 Register
            `REG_PATTERNMASK16_ADDR : begin
                for (byte_index = 0; byte_index <= (`REG_PATTERNMASK16_WIDTH/8-1); byte_index = byte_index +1)
                    reg_data_out [byte_index*8 +: 8] = patternmask16_reg [(C_S_AXI_DATA_WIDTH/8-byte_index-1)*8 +: 8];
            end
            //Matchcount Register
            `REG_MATCHCOUNT_ADDR : begin
                reg_data_out [`REG_MATCHCOUNT_BITS] =  ip2cpu_matchcount_reg;
            end
            //Indirectaddress Register
            `REG_INDIRECTADDRESS_ADDR : begin
                reg_data_out [`REG_INDIRECTADDRESS_BITS] =  indirectaddress_reg;
            end
            //Indirectwrdata Register
            `REG_INDIRECTWRDATA_ADDR : begin
                reg_data_out [`REG_INDIRECTWRDATA_BITS] =  indirectwrdata_reg;
            end
            //Indirectreply Register
            `REG_INDIRECTREPLY_ADDR : begin
                reg_data_out [`REG_INDIRECTREPLY_BITS] =  indirectreply_reg;
            end
            //Indirectcommand Register
            `REG_INDIRECTCOMMAND_ADDR : begin
                reg_data_out [`REG_INDIRECTCOMMAND_BITS] =  indirectcommand_reg;
            end
            //Indirectconfig Register
            `REG_INDIRECTCONFIG_ADDR : begin
                reg_data_out [`REG_INDIRECTCONFIG_BITS] =  indirectconfig_reg;
            end
            //Default return value
            default: begin
                reg_data_out [31:0] =  32'hDEADBEEF;
            end

        endcase

    end//end of assigning data to IP2Bus_Data bus

    //Read only registers, not cleared
    //Nothing to do here....

//Read only registers, cleared on read (e.g. counters)
    always @(posedge clk)
    if (!resetn_sync) begin
        pktin_reg_clear <= #1 1'b0;
        pktin_reg_clear_d <= #1 1'b0;
        pktout_reg_clear <= #1 1'b0;
        pktout_reg_clear_d <= #1 1'b0;
    end
    else begin
        pktin_reg_clear <= #1 pktin_reg_clear_d;
        pktin_reg_clear_d <= #1(reg_rden && (axi_araddr==`REG_PKTIN_ADDR)) ? 1'b1 : 1'b0;
        pktout_reg_clear <= #1 pktout_reg_clear_d;
        pktout_reg_clear_d <= #1(reg_rden && (axi_araddr==`REG_PKTOUT_ADDR)) ? 1'b1 : 1'b0;
    end


// Output register or memory read data
    always @( posedge S_AXI_ACLK )
    begin
      if ( S_AXI_ARESETN == 1'b0 )
        begin
          axi_rdata  <= 0;
        end
      else
        begin
          // When there is a valid read address (S_AXI_ARVALID) with
          // acceptance of read address by the slave (axi_arready),
          // output the read dada
          if (reg_rden)
            begin
              axi_rdata <= reg_data_out/*ip2bus_data*/;     // register read data /* some new changes here */
            end
        end
    end

    //////////////////////////////////
    // Implement Indirect Access
	//////////////////////////////////
	

  //--------------------- Internal Parameters-------------------------
   localparam NUM_INDIRECT_STATES                = 6;
   localparam IDLE_INDIRECT_STATE                = 1;
   localparam WRITE_INDIRECT_STATE               = 2;
   localparam WRITE_WAIT_INDIRECT_STATE          = 4;
   localparam READ_INDIRECT_STATE                = 8;
   localparam READ_WAIT_INDIRECT_STATE           = 16;
   localparam INDIRECT_DONE_STATE                = 32;
   localparam INDIRECT_WRITE                     = 0;
   localparam INDIRECT_READ                      = 1;
   localparam INDIRECT_WRITE_TA                  = 1;
   localparam INDIRECT_WRITE_WS                  = 0;
  //------------------------------------------------------------------
   
   reg  [NUM_INDIRECT_STATES-1:0]           indirect_state, indirect_state_next, indirect_state_last;
   wire                            indirect_trigger;
   wire                            indirect_type;
   reg                             indirect_status, indirect_status_next;
   wire [3:0]                      indirect_address_increment;
   wire                            indirect_write_type;
   wire [10:0]                     indirect_timeout;
   wire [15:0]                     indirect_repeat_count;
   reg  [15:0]                     indirect_remaining,indirect_remaining_next;
   reg  [10:0]                     indirect_timeout_count, indirect_timeout_count_next;
   reg                             indirect_reply_valid;
   reg  [31:0]                     indirect_address,indirect_address_next;
   reg  [3:0]                      indirect_memory_select,indirect_memory_select_next;
   wire                             indirect_command_done;
   
   assign   indirect_trigger = indirectcommand_reg[0];
   assign   indirect_type    = indirectcommand_reg[4];
   assign   indirect_address_increment = indirectconfig_reg[3:0];
   assign   indirect_write_type = indirectconfig_reg[4];
   assign   indirect_timeout    = indirectconfig_reg[15:5];
   assign   indirect_repeat_count = indirectconfig_reg[31:16];
   
 always @(*) begin
      indirect_state_next   = indirect_state;
      indirect_status_next  = indirect_status;
      indirect_remaining_next = indirect_remaining;
      indirect_timeout_count_next = indirect_timeout_count;
      indirect_address_next      = indirect_address;
      indirect_memory_select_next = indirect_memory_select;
      case(indirect_state)
        IDLE_INDIRECT_STATE: begin
     	   if(indirect_trigger) begin
     	      indirect_state_next= (indirect_type == INDIRECT_WRITE) ? WRITE_INDIRECT_STATE : READ_INDIRECT_STATE;
     	      indirect_remaining_next = (indirect_repeat_count == 0) ? 16'h1 : indirect_repeat_count;
     	      indirect_timeout_count_next   = indirect_timeout;
     	      indirect_address_next   =  indirectaddress_reg; //This is the address in the user register
     	      indirect_memory_select_next = indirectaddress_reg[31:28];
     	   end
	    end
	    
	    READ_INDIRECT_STATE: begin
		     indirect_state_next = READ_WAIT_INDIRECT_STATE;
	    end
	    READ_WAIT_INDIRECT_STATE: begin
	         if (indirect_reply_valid) begin
	            indirect_state_next = INDIRECT_DONE_STATE;
	            indirect_status_next =0;
	         end
	         if (indirect_timeout_count==0) begin
	            indirect_state_next = INDIRECT_DONE_STATE;
	            indirect_status_next = 1; 
	         end
	         indirect_timeout_count_next = indirect_timeout_count-1;
	     end
	     WRITE_INDIRECT_STATE: begin
	         indirect_state_next = WRITE_WAIT_INDIRECT_STATE;
	     end
	     WRITE_WAIT_INDIRECT_STATE:  begin
	         if (((indirect_write_type == INDIRECT_WRITE_TA) && (indirect_reply_valid)) || ((indirect_write_type == INDIRECT_WRITE_WS) && (indirect_timeout_count==0))) begin
	           indirect_remaining_next = indirect_remaining - 1;
	           indirect_address_next = indirect_address+indirect_address_increment;
	           if (indirect_remaining==1) begin
	              indirect_state_next = INDIRECT_DONE_STATE;
	           end
	         end
	         else 
	           if (indirect_timeout_count==0) begin
	         	indirect_state_next = INDIRECT_DONE_STATE;
	         	indirect_status_next = 1; 
	         end
             indirect_timeout_count_next = indirect_timeout_count==0 ? 0 : indirect_timeout_count-1;
	     end
	     INDIRECT_DONE_STATE: begin
	        indirect_state_next= IDLE_INDIRECT_STATE;
	     end
	     default: begin
	         indirect_state_next= IDLE_INDIRECT_STATE;
	     end
      endcase // case(state)
   end // always @ (*)
   
    assign indirect_command_done = (indirect_state==INDIRECT_DONE_STATE);
   
   always @(posedge clk) begin
      if(~resetn_sync) begin
         indirect_state <= #1 IDLE_INDIRECT_STATE;
         indirect_state_last <= #1 IDLE_INDIRECT_STATE;
         indirect_status <= #1 1'b0;
         indirect_remaining <= #1 0;
         indirect_timeout_count <= #1 0;
         indirect_address   <= #1 0;
         indirect_memory_select <= #1 0;
         indirectcommand_reg <= #1 `REG_INDIRECTCOMMAND_DEFAULT;
      end
      else begin
         indirect_state <= #1 indirect_state_next;
         indirect_state_last <= #1 indirect_state;
         indirect_status <= #1 indirect_status_next;
         indirect_remaining <= #1 indirect_remaining_next;
         indirect_timeout_count <= #1 indirect_timeout_count_next;
         indirect_address   <= #1  indirect_address_next;
         indirect_memory_select <= #1 indirect_memory_select_next;
         indirectcommand_reg <= #1  indirect_command_done ? {indirect_status,indirectcommand_reg[7:4],4'h0} : 
                                    indirectcommand_reg_update ? indirectcommand_reg_internal: 
                                    indirectcommand_reg;
      end
   end   
   

       
       always @(posedge clk) begin
         if  (~resetn_sync) begin
           pktsizemem_addr <= #1 0;
           pktsizemem_data <= #1 0;
           pktsizemem_rd_wrn<= #1 0;
           pktsizemem_cmd_valid <= #1 0;
         end 
         else begin
           pktsizemem_addr <= #1 indirect_address;
           pktsizemem_data <= #1 indirectwrdata_reg;
           pktsizemem_rd_wrn<= #1 indirect_type;
           pktsizemem_cmd_valid <= #1 (32'h0==(indirect_memory_select<<28)) && ((indirect_state == WRITE_INDIRECT_STATE) || (indirect_state == READ_INDIRECT_STATE));
         end 
       end

       
       always @(posedge clk) begin
         if  (~resetn_sync) begin
           ipgmem_addr <= #1 0;
           ipgmem_data <= #1 0;
           ipgmem_rd_wrn<= #1 0;
           ipgmem_cmd_valid <= #1 0;
         end 
         else begin
           ipgmem_addr <= #1 indirect_address;
           ipgmem_data <= #1 indirectwrdata_reg;
           ipgmem_rd_wrn<= #1 indirect_type;
           ipgmem_cmd_valid <= #1 (32'h10000000==(indirect_memory_select<<28)) && ((indirect_state == WRITE_INDIRECT_STATE) || (indirect_state == READ_INDIRECT_STATE));
         end 
       end

       
       always @(posedge clk) begin
         if  (~resetn_sync) begin
           burstmem_addr <= #1 0;
           burstmem_data <= #1 0;
           burstmem_rd_wrn<= #1 0;
           burstmem_cmd_valid <= #1 0;
         end 
         else begin
           burstmem_addr <= #1 indirect_address;
           burstmem_data <= #1 indirectwrdata_reg;
           burstmem_rd_wrn<= #1 indirect_type;
           burstmem_cmd_valid <= #1 (32'h20000000==(indirect_memory_select<<28)) && ((indirect_state == WRITE_INDIRECT_STATE) || (indirect_state == READ_INDIRECT_STATE));
         end 
       end

       
       always @(posedge clk) begin
         if  (~resetn_sync) begin
           bwmem_addr <= #1 0;
           bwmem_data <= #1 0;
           bwmem_rd_wrn<= #1 0;
           bwmem_cmd_valid <= #1 0;
         end 
         else begin
           bwmem_addr <= #1 indirect_address;
           bwmem_data <= #1 indirectwrdata_reg;
           bwmem_rd_wrn<= #1 indirect_type;
           bwmem_cmd_valid <= #1 (32'h30000000==(indirect_memory_select<<28)) && ((indirect_state == WRITE_INDIRECT_STATE) || (indirect_state == READ_INDIRECT_STATE));
         end 
       end

       
       always @(posedge clk) begin
         if  (~resetn_sync) begin
           bwtsmem_addr <= #1 0;
           bwtsmem_data <= #1 0;
           bwtsmem_rd_wrn<= #1 0;
           bwtsmem_cmd_valid <= #1 0;
         end 
         else begin
           bwtsmem_addr <= #1 indirect_address;
           bwtsmem_data <= #1 indirectwrdata_reg;
           bwtsmem_rd_wrn<= #1 indirect_type;
           bwtsmem_cmd_valid <= #1 (32'h40000000==(indirect_memory_select<<28)) && ((indirect_state == WRITE_INDIRECT_STATE) || (indirect_state == READ_INDIRECT_STATE));
         end 
       end

       
       always @(posedge clk) begin
         if  (~resetn_sync) begin
           ppsmem_addr <= #1 0;
           ppsmem_data <= #1 0;
           ppsmem_rd_wrn<= #1 0;
           ppsmem_cmd_valid <= #1 0;
         end 
         else begin
           ppsmem_addr <= #1 indirect_address;
           ppsmem_data <= #1 indirectwrdata_reg;
           ppsmem_rd_wrn<= #1 indirect_type;
           ppsmem_cmd_valid <= #1 (32'h50000000==(indirect_memory_select<<28)) && ((indirect_state == WRITE_INDIRECT_STATE) || (indirect_state == READ_INDIRECT_STATE));
         end 
       end

       
       always @(posedge clk) begin
         if  (~resetn_sync) begin
           flowidmem_addr <= #1 0;
           flowidmem_data <= #1 0;
           flowidmem_rd_wrn<= #1 0;
           flowidmem_cmd_valid <= #1 0;
         end 
         else begin
           flowidmem_addr <= #1 indirect_address;
           flowidmem_data <= #1 indirectwrdata_reg;
           flowidmem_rd_wrn<= #1 indirect_type;
           flowidmem_cmd_valid <= #1 (32'h60000000==(indirect_memory_select<<28)) && ((indirect_state == WRITE_INDIRECT_STATE) || (indirect_state == READ_INDIRECT_STATE));
         end 
       end

       
       always @(posedge clk) begin
         if  (~resetn_sync) begin
           windowsizemem_addr <= #1 0;
           windowsizemem_data <= #1 0;
           windowsizemem_rd_wrn<= #1 0;
           windowsizemem_cmd_valid <= #1 0;
         end 
         else begin
           windowsizemem_addr <= #1 indirect_address;
           windowsizemem_data <= #1 indirectwrdata_reg;
           windowsizemem_rd_wrn<= #1 indirect_type;
           windowsizemem_cmd_valid <= #1 (32'h70000000==(indirect_memory_select<<28)) && ((indirect_state == WRITE_INDIRECT_STATE) || (indirect_state == READ_INDIRECT_STATE));
         end 
       end

       always @(posedge clk) begin
          if  (~resetn_sync) begin
             indirectreply_reg <= #1 0;
             indirect_reply_valid <= #1 0; 
          end 
          else begin 
             indirectreply_reg <= #1 32'h0==(indirect_memory_select<<28) ? pktsizemem_reply :32'h10000000==(indirect_memory_select<<28) ? ipgmem_reply :32'h20000000==(indirect_memory_select<<28) ? burstmem_reply :32'h30000000==(indirect_memory_select<<28) ? bwmem_reply :32'h40000000==(indirect_memory_select<<28) ? bwtsmem_reply :32'h50000000==(indirect_memory_select<<28) ? ppsmem_reply :32'h60000000==(indirect_memory_select<<28) ? flowidmem_reply :32'h70000000==(indirect_memory_select<<28) ? windowsizemem_reply : 0;
      indirect_reply_valid <= #1 32'h0==(indirect_memory_select<<28) ? pktsizemem_reply_valid :32'h10000000==(indirect_memory_select<<28) ? ipgmem_reply_valid :32'h20000000==(indirect_memory_select<<28) ? burstmem_reply_valid :32'h30000000==(indirect_memory_select<<28) ? bwmem_reply_valid :32'h40000000==(indirect_memory_select<<28) ? bwtsmem_reply_valid :32'h50000000==(indirect_memory_select<<28) ? ppsmem_reply_valid :32'h60000000==(indirect_memory_select<<28) ? flowidmem_reply_valid :32'h70000000==(indirect_memory_select<<28) ? windowsizemem_reply_valid : 0;
          end 
        end
  
endmodule
